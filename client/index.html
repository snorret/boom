<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
<!--    <meta name="viewport" content="width=device-width, initial-scale=1">-->
    <meta name="viewport" content="height=device-height, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">
    <title>Pangpang</title>
    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
<!--    <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet">-->
    <!-- Custom styles for this template -->
    <link href="css/jumbotron-narrow.css" rel="stylesheet">
    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
<!--    <script src="../../assets/js/ie-emulation-modes-warning.js"></script>-->
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>	
	<script src="socket.io/socket.io.js"></script>
    
	<link href="css/target.css" rel="stylesheet">
</head>
    
<body>
    <!-- <br> --> <!-- För att notifyer ska få plats utan att lägga sig över meny... -->
    <div class="container" id="divMainContainer" style="max-height:100%; height: 100vh">
        <div id="divHeader" class="header clearfix">
            <nav>
                <ul class="nav nav-pills pull-right">
                    <li role="presentation" id="menuBoard" class="menu"><a href="#">Board</a></li>
                    <li role="presentation" id="menuTargetMain" class="menu active"><a href="#">Target</a></li>
                    <li role="presentation" id="menuSettings" class="menu "><a href="#">Settings</a></li>
                </ul>
            </nav>
            <br><br>
            
            <div id="numberOfClients">Number of clients connected: <span id="numberOfClientsValue">Unknown</span></div>
        </div>
        <div id="divBody">
            <div class="jumbotron" id="divBoard" style="display: none; height: 100%">
                <h1>Tavla</h1>
            </div>
            <div id="divTargetMain" style="height:100%">
                <div id="divTarget" style="position: absolute; left: 50%; display:inline-block; border: solid;">
                    <img id="imgTarget" style="height: 100%;" src="images/target.png"/>
                </div>
            </div>
            <div id="divSettings" style="display: none; height: 100%; text-algin: left">
                <label>Bullet hole size:</label><br>
                <input type="text" class="setting numbersOnly" id="iSetting1" placeholder="3.14159265359"> <!-- because Pi!!! -->
                <br><br>
                <label>Setting2:</label><br>
                <input type="text" class="setting" id="iSetting2" placeholder="Enter 'Setting2'">
                <br><br>
                <label>Setting3:</label><br>
                <input type="text" class="setting" id="iSetting3" placeholder="Enter 'Setting3'">
                <br><br>
                <label>Setting4:</label><br>
                <input type="text" class="setting" id="iSetting4" placeholder="Enter 'Setting4'">
            </div>

<!--            <p class="btn-rensa"><a class="btn btn-lg btn-success" href="#" role="button" id="btnClear">Rensa</a></p>-->
        </div>
        <footer class="footer" id="fotterId">
            <p class="btn-rensa"><a class="btn btn-lg btn-success" href="#" role="button" id="btnClear">Rensa</a></p>
        </footer>
    </div>
    <!-- /container -->
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
<!--    <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>-->
    
    <script type="text/javascript">

    var Boom = {};
    (function(Boom){
        
        var bulletSize = 20;
        var bulletSizeMax = 100;
        var bulletSizeMin = 10;
        
        var socket;
        
        eventTypes = {
            setting : "setting",
            targetData : "targetData"
        }
        
		Boom.InitSocketIo = function() {
			socket = io();
            socket.on('numberOfClients', function(value) {
                $('#numberOfClientsValue').text(value)
            });
            
            socket.on('testerEvent', function(data){
                if(data && data.message){
                    alert(data.message);
                }
            });
		};
        
        Boom.SendMessage = function(type, value) {
            if(socket && eventTypes[type] && value) {
                socket.emit('clientEvent', type + "|" + value);
            }
        };
        
 
        
        Boom.InitView = function() {
            $(window).on("orientationchange load resize", function () {
                Boom.ResizeBodyDiv();
            });
            
			// knyt knappar osv..
            $('#btnClear').on('click', Boom.BtnClear);
            
            // meny..
            $('.menu').on('click', Boom.MenuClick);

            $("#divTarget").click(function (e) {
                //Boom.targetClickDBE(e);
                Boom.targetClickTest(e);
            });
            
            $(".setting").on('blur', Boom.SaveSetting);
            
            Boom.ResizeBodyDiv();
        };
        
        Boom.ResizeBodyDiv = function() {
            var mainHeight = $("#divMainContainer").height();
            var headHeight = $("#divHeader").height();
            var fotterHeight = $("#fotterId").height();
            var testHeight = mainHeight - headHeight - fotterHeight - 12;
            
            
            $("#divBody").css('height',testHeight);

            if($("#menuTargetMain").hasClass("active")) {
                // sätt img size.. - kolla vad som "slår i" först..
                var divTargetMain = $("#divTargetMain");
                var targetMainHeight = divTargetMain.height();
                var targetMainWidth = divTargetMain.width();

                if(targetMainHeight < targetMainWidth) {
                    $("#imgTarget").css('width',"auto");
                    $("#imgTarget").css('height',targetMainHeight);
                }
                else {
                    $("#imgTarget").css('height',"auto");
                    $("#imgTarget").css('width',targetMainWidth);
                }

                // center targetDiv
                $("#divTarget").css('margin-left',-$("#divTarget").outerWidth()/2);
            }
        };

        Boom.targetClickTest = function(e) {
            if($("#divTarget").hasClass("noTarget")) {
                return;
            }
            
            var divTarget = $("#divTarget");
            var x = e.pageX - divTarget.offset().left;
            var y = e.pageY - divTarget.offset().top;
            
            
            // 1)	klicka på tavlan, rita upp en så stor cirkel som det går, innan vi "slår i" en av micarna (center = klickets koordinater). (-1;-1, -1;1, 1;-1, 1;-1) (hörnen..)
            // distance to closest corner..
            var divLeft = 0;
            var divTop = 0;
            var height = divTarget.height();
            var width = divTarget.width();
            
            
            // test draw corners.
            // top left 
            Boom.testDrawDot(divLeft, divTop, 10, "type1");
            // top right
            Boom.testDrawDot(divLeft + width, divTop, 10, "type1");
            // bottom left
            Boom.testDrawDot(divLeft, divTop + height, 10, "type1");
            // bottom right
            Boom.testDrawDot(divLeft + width, divTop + height, 10, "type1");
            
            var infoList = [];
            
            var rTopLeft = Math.sqrt(Math.pow((x - divLeft), 2) + Math.pow((y - divTop), 2));
            var rTopright = Math.sqrt(Math.pow((x - (divLeft + width)), 2) + Math.pow((y - divTop), 2));
            var rBottomLeft = Math.sqrt(Math.pow((x - divLeft), 2) + Math.pow((y - (divTop + height)), 2));
            var rBottomRight = Math.sqrt(Math.pow((x - (divLeft + width)), 2) + Math.pow((y - (divTop + height)), 2));
            
            infoList[0] = {'x' : divLeft, 'y' : divTop, 'r' : rTopLeft};
            infoList[1] = {'x' : divLeft + width, 'y' : divTop, 'r' : rTopright};
            infoList[2] = {'x' : divLeft, 'y' : divTop + height, 'r' : rBottomLeft};
            infoList[3] = {'x' : divLeft + width, 'y' : divTop + height, 'r' : rBottomRight};
            
            var r = Math.min(rTopLeft, rTopright, rBottomLeft, rBottomRight);
            
            
            Boom.testDrawDot(x, y, 3, "type1"); // klicket..
            Boom.testDrawDot(x, y, r, "type2");
            //-1
            
            // 2)	Rita upp tre cirklar som utgår ifrån hörnen som inte "träffades" av den första cirkeln. cirklarna ska ha en radie som är avståndet från klicket till respektive cirkels center (ett av hörnen) - den första cirkelns radie
            
            $.each(infoList, function(i, obj) {
                if(obj.r != r) {
                    // rita ut dom andra.
                    Boom.testDrawDot(obj.x, obj.y, obj.r - r, "type3");
                }
            })
            
            // Send test data to server
            
            // avståndet / divTarget.width... (alltid samma som height)
            var testItem0 = r == rTopLeft ? 0 : (rTopLeft / 2 / width);
            var testItem1 = r == rTopright ? 0 : (rTopright / 2 / width);
            var testItem2 = r == rBottomLeft ? 0 : (rBottomLeft / 2 / width);
            var testItem3 = r == rBottomRight ? 0 : (rBottomRight / 2/ width);
            
            Boom.SendMessage(eventTypes.targetData, "0:"+testItem0+"#1:"+testItem1+"#2:"+testItem2+"#3:"+testItem3);
        };
        
        Boom.testDrawDot = function(x, y, r, type){
          $("#divTarget").append(
                $('<div class="circleBase ' + type + ' noTarget"></div>')
                    .css('position', 'absolute')
                    .css('top',  (y - (r)) + 'px')
                    .css('left', (x - (r)) + 'px')
                    .css('width', r*2 + 'px')
                    .css('height', r*2 + 'px')
            );  
        };
        
//        Boom.targetClickDBE = function(e) {
//          if($("#divTarget").hasClass("noTarget")) {
//                return;
//            }
//            var testY = e.pageY - $("#divTarget").offset().top;
//            var testX = e.pageX - $("#divTarget").offset().left;
//            var mainDiv = $("#divMainContainer");
//
//            $("#divTarget").append(
//                $('<div class="circleBase type2 clickPoint"></div>')
//                    .css('position', 'absolute')
//                    .css('top',  (testY - (bulletSize/2)) + 'px')
//                    .css('left', (testX - (bulletSize/2)) + 'px')
//                    .css('width', bulletSize + 'px')
//                    .css('height', bulletSize + 'px')
//            );
//
//            Boom.testIntersect();  
//        };
//        
//        Boom.testIntersect = function() {
//            
//            var points = [];
//            
//            var i = 0;
//            
//            $(".clickPoint").each(function() {
//                points[i] = Boom.testGetDivCenter(this);
//                i++;
//            });
//            
//            // fultest..
//            if(points.length == 3) {
//                var p1 = points[points.length-3];
//                var p2 = points[points.length-2];
//                var p3 = points[points.length-1];
//                
//                //var result = Boom.GetIntersectPoint(p1,p2);
//                
//                var result = Boom.GetIntersectionThreePoints(p1,p2, p3);
//                
//                $("#divTarget").append(
//                    $('<div class="circleBase type1 bulletHole"></div>')
//                        .css('position', 'absolute')
//                        .css('top',  (result.y - (10/2)) + 'px')
//                        .css('left', (result.x - (10/2)) + 'px')
//                        .css('width', result.r + 'px')
//                        .css('height', result.r + 'px')
//                );
//                
//                // Väääääldigt lika.. så behöver inte denna..
////                $("#divTarget").append(
////                    $('<div class="circleBase type3 noTarget"></div>')
////                        .css('position', 'absolute')
////                        .css('top',  (result.yi_prime - (10/2)) + 'px')
////                        .css('left', (result.xi_prime - (10/2)) + 'px')
////                        .css('width', 10 + 'px')
////                        .css('height', 10 + 'px')
////                );
//            }
//            else if(points.length > 3) {
//                $(".circleBase").remove();
//            }
//        };
//        
//        Boom.DrawDot = function(result, type){
//            $("#divTarget").append(
//                $('<div class="circleBase type1 noTarget"></div>')
//                    .css('position', 'absolute')
//                    .css('top',  (result.y - (5/2)) + 'px')
//                    .css('left', (result.x - (5/2)) + 'px')
//                    .css('width', 5 + 'px')
//                    .css('height', 5 + 'px')
//            );
//        };
//        
//        Boom.GetIntersectionThreePoints = function(p1, p2, p3) {            
//            var result = Boom.GetIntersectPoint(p1, p2);
//            
//            var newP1 = {'x' : result.xi, 'y' : result.yi, 'r' : 1};
//            //Boom.DrawDot(newP1, "type1");
//            
//            result = Boom.GetIntersectPoint(newP1, p3);
//            
//            var newP2 = {'x' : result.xi, 'y' : result.yi, 'r' : 1};
//            //Boom.DrawDot(newP2, "type1");
//            
//            result = Boom.GetIntersectPoint(newP1, newP2);
//            
//            var newP3 = {'x' : result.xi, 'y' : result.yi, 'r' : 1};
//            //Boom.DrawDot(newP3, "type1");
//            
//            // sista.. jag lovar.
//            result = Boom.GetIntersectPoint(newP3, newP2);
//            
//            var yey = {'x' : result.xi, 'y' : result.yi, 'r' : (bulletSize / 2)};
//            
//            return yey;
//        };
//        
//        Boom.GetIntersectPoint = function(p1, p2) {
//            var p1r = p1.r;
//            var p2r = p2.r;
//            
//            var result = false;
//            do {
//                p1r++;
//                p2r++;
//                result = Boom.TestIntersection(p1.x, p1.y, p1r, p2.x, p2.y, p2r);
//            }while(!result)
//
//            result = false;
//            do {
//                p1r -= 0.0001;
//                p2r -= 0.0001;
//                result = Boom.TestIntersection(p1.x, p1.y, p1r, p2.x, p2.y, p2r);
//            }while(result)
//                
//            p1r += 0.0001;
//            p2r += 0.0001;
//
//            return Boom.TestIntersection(p1.x, p1.y, p1r, p2.x, p2.y, p2r);
//        };
//        
//        Boom.TestIntersection = function(x0, y0, r0, x1, y1, r1) {
//            var a, dx, dy, d, h, rx, ry;
//            var x2, y2;
//
//            /* dx and dy are the vertical and horizontal distances between
//             * the circle centers.
//             */
//            dx = x1 - x0;
//            dy = y1 - y0;
//
//            /* Determine the straight-line distance between the centers. */
//            d = Math.sqrt((dy*dy) + (dx*dx));
//
//            /* Check for solvability. */
//            if (d > (r0 + r1)) {
//                /* no solution. circles do not intersect. */
//                return false;
//            }
//            if (d < Math.abs(r0 - r1)) {
//                /* no solution. one circle is contained in the other */
//                return false;
//            }
//
//            /* 'point 2' is the point where the line through the circle
//             * intersection points crosses the line between the circle
//             * centers.  
//             */
//
//            /* Determine the distance from point 0 to point 2. */
//            a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
//
//            /* Determine the coordinates of point 2. */
//            x2 = x0 + (dx * a/d);
//            y2 = y0 + (dy * a/d);
//
//            /* Determine the distance from point 2 to either of the
//             * intersection points.
//             */
//            h = Math.sqrt((r0*r0) - (a*a));
//
//            /* Now determine the offsets of the intersection points from
//             * point 2.
//             */
//            rx = -dy * (h/d);
//            ry = dx * (h/d);
//
//            /* Determine the absolute intersection points. */
//            var xi = x2 + rx;
//            var xi_prime = x2 - rx;
//            var yi = y2 + ry;
//            var yi_prime = y2 - ry;
//
//            //return [xi, xi_prime, yi, yi_prime];
//            
//            return {'xi' : xi, 'xi_prime' : xi_prime, 'yi' : yi, 'yi_prime': yi_prime};
//            
//        };
//        
//        Boom.TestIntersection = function(x0, y0, r0, x1, y1, r1, x2, y2, r2) {
//            var a, dx, dy, d, h, rx, ry;
//            var x2, y2;
//
//            /* dx and dy are the vertical and horizontal distances between
//             * the circle centers.
//             */
//            dx = x1 - x0;
//            dy = y1 - y0;
//
//            /* Determine the straight-line distance between the centers. */
//            d = Math.sqrt((dy*dy) + (dx*dx));
//
//            /* Check for solvability. */
//            if (d > (r0 + r1)) {
//                /* no solution. circles do not intersect. */
//                return false;
//            }
//            if (d < Math.abs(r0 - r1)) {
//                /* no solution. one circle is contained in the other */
//                return false;
//            }
//
//            /* 'point 2' is the point where the line through the circle
//             * intersection points crosses the line between the circle
//             * centers.  
//             */
//
//            /* Determine the distance from point 0 to point 2. */
//            a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
//
//            /* Determine the coordinates of point 2. */
//            x2 = x0 + (dx * a/d);
//            y2 = y0 + (dy * a/d);
//
//            /* Determine the distance from point 2 to either of the
//             * intersection points.
//             */
//            h = Math.sqrt((r0*r0) - (a*a));
//
//            /* Now determine the offsets of the intersection points from
//             * point 2.
//             */
//            rx = -dy * (h/d);
//            ry = dx * (h/d);
//
//            /* Determine the absolute intersection points. */
//            var xi = x2 + rx;
//            var xi_prime = x2 - rx;
//            var yi = y2 + ry;
//            var yi_prime = y2 - ry;
//
//            //return [xi, xi_prime, yi, yi_prime];
//            
//            return {'xi' : xi, 'xi_prime' : xi_prime, 'yi' : yi, 'yi_prime': yi_prime};
//            
//        };
//        
        Boom.testGetDivCenter = function(div) {
            var radius = 1; // cirkel..

            var centerX = div.offsetLeft + radius;
            var centerY = div.offsetTop + radius;
            
            
            return {'x' : centerX, 'y' : centerY, 'r' : radius};
        };
        
        Boom.SaveSetting = function(elem) {
            //alert(elem.target.id);
            if(elem && elem.target && elem.target.id){
                var elemTarget = $("#" + elem.target.id);
                if(elemTarget.val()) {
                    
                    var elemVal =  elemTarget.val().replace(",", "."); // numeric är med punkt..
                    
                    if($.isNumeric(elemVal)) {
                        var tempBulletSize = parseFloat(elemVal);
                        
                        if (tempBulletSize <= bulletSizeMax && tempBulletSize >= bulletSizeMin){
                            bulletSize = tempBulletSize;
                            Boom.Notify(notifyType.Success, "Bullet size changed to: " + elemTarget.val());
                            
                            Boom.SendMessage(eventTypes.setting, "bulletSize set to " + bulletSize);
                            
                        }
                        else {
                            Boom.Notify(notifyType.Info, "Bullet size has to be between " + bulletSizeMin + " and " + bulletSizeMax);
                        }
                    }
                    else {
                        Boom.Notify(notifyType.Error, "Failed to update bullet size: input is not numeric", 2000);
                    }
                    
                    elemTarget.attr("placeholder", bulletSize);
                    elemTarget.val('');
                }
            }
        }
                
        notifyType = {
            Error : "salmon",
            Success : "lightgreen",
            Info : "Khaki"
        }
        
        Boom.Notify = function(notifyType, msg, delay = 5000) {
            $(".notifyer").remove(); // remove prev. notifyers from dom..
                        
            var mainDiv = $("#divMainContainer");
            var left = mainDiv.offset().left

            var notifyer = $('<div class="container notifyer" style="background-color: '+notifyType+'; border-radius: 10px;"><center><label id="notifyerLabel">'+ msg +'</label></center></div>')
                                .css('position', 'absolute')
                                .css("top", "0px")
                                .css("left", left+ "px")
                                .css('width', '100%')
                                .css('height', '17px');
            
            notifyer.click(function (e) {
                notifyer.remove();
            });
            

            notifyer.hide().appendTo(mainDiv).fadeIn().delay(delay).fadeOut();
        }
        
        Boom.MenuClick = function(e){
            if(e) e.preventDefault();
            
            var btnId = this.id;
            
            $(".menu").each(function() {
                var div = $("#" + this.id.replace('menu', 'div'));
                
                if(this.id === btnId){
                    Boom.ActivateDiv(this, div);
                }
                else {
                    Boom.DeactivateDiv(this, div);
                }
            });
        };
        
        Boom.ActivateDiv = function(item, div) {
            $(item).addClass( "active" );
            if(div){
                div.visible();
                Boom.ResizeBodyDiv();
            }
        }
        
        Boom.DeactivateDiv = function(item, div) {
            $(item).removeClass( "active" );
            
            if(div){
                div.invisible();
            }
        }
        
        Boom.BtnClear = function(e){
            if(e) e.preventDefault();
            $(".circleBase").remove();
        };
        
        jQuery.fn.visible = function() {
            return this.css('display','block');
        };

        jQuery.fn.invisible = function() {
            return this.css('display','none');
        };
        
        jQuery.fn.center = function () {
            //this.css("position","absolute");
            //this.css("top", Math.max(0, (($(window).height() - $(this).outerHeight()) / 2) + $(window).scrollTop()) + "px");
            this.css("left", Math.max(0, (($(window).width() - $(this).outerWidth()) / 2)) + "px");
            return this;
        }
        
    }(Boom));
    
    $(document).ready(function () {
        Boom.InitSocketIo();
		Boom.InitView();
    });

    </script>
</body>
</html>
